<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Network Viewer</title>
  <style>
    html, body { height:100%; margin:0; padding:0; }
    #cy { width:100%; height:100vh; display:block; }
    #controls { position: absolute; top: 10px; left: 10px; z-index: 999; background: rgba(255,255,255,0.9); padding:8px; border-radius:6px; box-shadow:0 2px 6px rgba(0,0,0,0.15); font-family: sans-serif; }
    #controls button { margin:2px; }
  </style>
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
</head>
<body>
  <div id="controls" aria-hidden="false">
    <button id="fit">Fit</button>
    <button id="reset">Reset View</button>
    <button id="layout">Re-run layout</button>
    <span id="info" style="margin-left:8px;font-size:12px;color:#333;"></span>
  </div>
  <div id="cy" role="application" aria-label="Network graph"></div>

  <script>
  // Default colors (will be overridden by postMessage)
  // Use let so we can replace these objects later
  let nodeTypeColors = {'Person': '#51e2f3', 'Company': '#73589a'};
  let edgeTypeColors = {'FOLLOWS': '#b97e34', 'WORKS AT': '#7a2550'};

  // Message queue + ready flag so messages arriving early are handled
  let _cyReady = false;
  let _pendingMessages = [];

  function applyStyles(cyInstance, nodeColors, edgeColors) {
    var style = [
      { selector: 'node', style: { 'label': 'data(label)', 'font-size': 12, 'text-valign': 'center', 'text-halign': 'center', 'color': '#222', 'text-outline-width': 0, 'width': 30, 'height': 30 } },
      { selector: 'edge', style: { 'width': 2, 'line-color': '#bbb', 'curve-style': 'bezier' } }
    ];
    Object.keys(nodeColors).forEach(function(typeName) {
      style.push({
        selector: 'node[type = "' + typeName + '"]',
        style: { 'background-color': nodeColors[typeName] }
      });
    });
    Object.keys(edgeColors).forEach(function(typeName) {
      style.push({
        selector: 'edge[type = "' + typeName + '"]',
        style: { 'line-color': edgeColors[typeName] }
      });
    });
    // Apply style safely
    try {
      cyInstance.style().fromJson(style).update();
      console.log('[viewer] applied styles', nodeColors, edgeColors);
    } catch (e) {
      console.error('[viewer] failed applying styles', e);
    }
  }

  // Load graph
  fetch('my-graph-cyto.json').then(r => r.json()).then(data => {
    const elements = data.elements || {};
    const cy = cytoscape({
      container: document.getElementById('cy'),
      elements: elements,
      style: [
        { selector: 'node', style: { 'label': 'data(label)', 'font-size': 12, 'text-valign': 'center', 'text-halign': 'center', 'color': '#222', 'text-outline-width': 0, 'width': 30, 'height': 30 } },
        { selector: 'edge', style: { 'width': 2, 'line-color': '#bbb', 'curve-style': 'bezier' } }
      ],
      layout: { name: 'cose', animate: true, gravity: 1, fit: true },
      wheelSensitivity: 0.2
    });

    // initial styles applied
    applyStyles(cy, nodeTypeColors, edgeTypeColors);

    // Mark ready and process any pending message
    _cyReady = true;
    if (_pendingMessages.length) {
      console.log('[viewer] processing', _pendingMessages.length, 'pending messages');
      _pendingMessages.forEach(function(d) {
        if (d.nodeTypeColors) nodeTypeColors = d.nodeTypeColors;
        if (d.edgeTypeColors) edgeTypeColors = d.edgeTypeColors;
        if (d.backgroundColor) {
          document.body.style.background = d.backgroundColor;
          document.getElementById('cy').style.background = d.backgroundColor;
        }
        applyStyles(cy, nodeTypeColors, edgeTypeColors);
      });
      _pendingMessages = [];
    }

    // message listener for color/background updates
    window.addEventListener('message', function(event) {
      // Optional: if you want to restrict origin, check event.origin here
      try {
        var d = event.data || {};
        if (d && d.type === 'updateColors') {
          console.log('[viewer] received updateColors', d);
          if (!_cyReady) {
            // queue it until cy is ready
            _pendingMessages.push(d);
            console.log('[viewer] queued message until cy ready');
            return;
          }
          if (d.nodeTypeColors) nodeTypeColors = d.nodeTypeColors;
          if (d.edgeTypeColors) edgeTypeColors = d.edgeTypeColors;
          if (d.backgroundColor) {
            document.body.style.background = d.backgroundColor;
            document.getElementById('cy').style.background = d.backgroundColor;
          }
          applyStyles(cy, nodeTypeColors, edgeTypeColors);
        }
      } catch(e) { console.error('[viewer] message handler error', e); }
    });

    // interactions: show node info on click
    cy.on('tap', 'node', function(evt) {
      var node = evt.target;
      var info = 'Node: ' + node.data('label') + (node.data('type') ? ' (' + node.data('type') + ')' : '');
      document.getElementById('info').textContent = info;
    });
    cy.on('tap', function(e) { if (e.target === cy) document.getElementById('info').textContent = ''; });

    document.getElementById('fit').addEventListener('click', function() { cy.fit(); });
    document.getElementById('reset').addEventListener('click', function() { cy.zoom(1); cy.center(); });
    document.getElementById('layout').addEventListener('click', function() { cy.layout({ name: 'cose', animate: true }).run(); });

    // Optional: inform parent that viewer is ready (plugin could listen for this if desired)
    try {
      window.parent.postMessage({type: 'viewerReady'}, '*');
    } catch(e) { /* ignore */ }
  }).catch(err => { console.error('[viewer] Failed loading graph JSON:', err); document.getElementById('info').textContent = 'Error loading graph data'; });
  </script>
</body>
</html>
